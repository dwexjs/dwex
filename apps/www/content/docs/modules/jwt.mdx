---
title: JWT Module
description: JSON Web Token authentication and signing
---

## Installation

```bash
bun add @dwex/jwt
```

## Basic Configuration

Register the JWT module in your app:

```typescript
import { Module } from "@dwex/core";
import { JwtModule } from "@dwex/jwt";

@Module({
  imports: [
    JwtModule.register({
      secret: "your-secret-key",
      signOptions: {
        expiresIn: "1h",
      },
    }),
  ],
})
export class AppModule {}
```

## Global Module

Make JWT available everywhere:

```typescript
@Module({
  imports: [
    JwtModule.register({
      global: true, // Available in all modules
      secret: process.env.JWT_SECRET,
      signOptions: {
        expiresIn: "15m",
      },
    }),
  ],
})
export class AppModule {}
```

## Configuration Options

```typescript
interface JwtModuleOptions {
  global?: boolean;
  secret: string;
  publicKey?: string;
  privateKey?: string;
  signOptions?: JwtSignOptions;
  verifyOptions?: JwtVerifyOptions;
  issuer?: string;
  audience?: string;
}
```

### Sign Options

```typescript
JwtModule.register({
  secret: "secret",
  signOptions: {
    expiresIn: "1h", // or '60m', '3600s', 3600
    issuer: "my-app",
    audience: "my-app-users",
    subject: "auth",
  },
});
```

## Using JwtService

Inject `JwtService` to sign and verify tokens:

```typescript
import { Injectable } from "@dwex/core";
import { JwtService } from "@dwex/jwt";

@Injectable()
export class AuthService {
  constructor(private readonly jwtService: JwtService) {}

  async login(user: User) {
    const payload = {
      sub: user.id,
      username: user.username,
      email: user.email,
    };

    const token = await this.jwtService.sign(payload);

    return {
      access_token: token,
    };
  }

  async validateToken(token: string) {
    try {
      const payload = await this.jwtService.verify(token);
      return payload;
    } catch (error) {
      return null;
    }
  }
}
```

## Signing Tokens

### Basic Signing

```typescript
const token = await this.jwtService.sign({
  sub: "user-id",
  username: "john",
});
```

### Custom Options

Override default options per token:

```typescript
const token = await this.jwtService.sign(
  {
    sub: "user-id",
  },
  {
    expiresIn: "7d",
    audience: "admin-users",
  }
);
```

### Payload Types

```typescript
interface TokenPayload {
  sub: string; // Subject (user ID)
  username: string;
  email: string;
  role: string;
  permissions: string[];
}

const token = await this.jwtService.sign<TokenPayload>({
  sub: user.id,
  username: user.username,
  email: user.email,
  role: user.role,
  permissions: user.permissions,
});
```

## Verifying Tokens

### Basic Verification

```typescript
try {
  const payload = await this.jwtService.verify(token);
  console.log(payload.sub); // user ID
} catch (error) {
  console.error("Invalid token");
}
```

### With Type Safety

```typescript
interface TokenPayload {
  sub: string;
  username: string;
}

const payload = await this.jwtService.verify<TokenPayload>(token);
console.log(payload.username); // Type-safe
```

### Verification Result

```typescript
const result = await this.jwtService.verify(token);

// Result contains:
// {
//   sub: 'user-id',
//   username: 'john',
//   iat: 1234567890,  // Issued at
//   exp: 1234571490,  // Expires at
//   iss: 'my-app',    // Issuer
//   aud: 'my-app-users' // Audience
// }
```

## Decode Without Verification

Decode token without verifying signature:

```typescript
const decoded = this.jwtService.decode(token);
// ⚠️ Don't use for authentication - payload is not verified!
```

## Asymmetric Keys (RS256)

Use public/private key pairs for better security:

### Generate Keys

```bash
# Generate private key
openssl genrsa -out private.key 2048

# Generate public key
openssl rsa -in private.key -pubout -out public.key
```

### Configure Module

```typescript
import { readFileSync } from "fs";

JwtModule.register({
  privateKey: readFileSync("./private.key", "utf8"),
  publicKey: readFileSync("./public.key", "utf8"),
  signOptions: {
    algorithm: "RS256",
    expiresIn: "1h",
  },
});
```

### Usage

```typescript
// Sign with private key
const token = await this.jwtService.sign(payload);

// Verify with public key
const decoded = await this.jwtService.verify(token);
```

## Multiple Token Types

Create different tokens for different purposes:

```typescript
@Injectable()
export class TokenService {
  constructor(private readonly jwtService: JwtService) {}

  // Short-lived access token
  async createAccessToken(userId: string) {
    return await this.jwtService.sign(
      { sub: userId, type: "access" },
      { expiresIn: "15m" }
    );
  }

  // Long-lived refresh token
  async createRefreshToken(userId: string) {
    return await this.jwtService.sign(
      { sub: userId, type: "refresh" },
      { expiresIn: "7d" }
    );
  }

  // Email verification token
  async createEmailToken(email: string) {
    return await this.jwtService.sign(
      { email, type: "email-verification" },
      { expiresIn: "24h" }
    );
  }

  async verifyAccessToken(token: string) {
    const payload = await this.jwtService.verify(token);
    if (payload.type !== "access") {
      throw new Error("Invalid token type");
    }
    return payload;
  }
}
```

## Error Handling

Handle different JWT errors:

```typescript
import { UnauthorizedException } from "@dwex/core";

async validateToken(token: string) {
	try {
		return await this.jwtService.verify(token);
	} catch (error) {
		if (error.name === 'TokenExpiredError') {
			throw new UnauthorizedException('Token expired');
		}
		if (error.name === 'JsonWebTokenError') {
			throw new UnauthorizedException('Invalid token');
		}
		if (error.name === 'NotBeforeError') {
			throw new UnauthorizedException('Token not active');
		}
		throw new UnauthorizedException('Token validation failed');
	}
}
```

## Best Practices

### 1. Use Environment Variables

```typescript
JwtModule.register({
  secret: process.env.JWT_SECRET!,
  signOptions: {
    expiresIn: process.env.JWT_EXPIRES_IN || "1h",
  },
});
```

### 2. Short Expiration Times

```typescript
// Access tokens: 15-30 minutes
JwtModule.register({
  secret: process.env.JWT_SECRET,
  signOptions: {
    expiresIn: "15m",
  },
});
```

### 3. Include Minimal Data

```typescript
// Good - minimal payload
const token = await this.jwtService.sign({
  sub: user.id,
  role: user.role,
});

// Avoid - too much data
const token = await this.jwtService.sign({
  ...user, // Don't include everything
  password: user.password, // Never include sensitive data!
});
```

### 4. Validate Claims

```typescript
const payload = await this.jwtService.verify(token);

// Validate issuer
if (payload.iss !== "my-app") {
  throw new UnauthorizedException("Invalid issuer");
}

// Validate audience
if (payload.aud !== "my-app-users") {
  throw new UnauthorizedException("Invalid audience");
}
```

### 5. Rotate Secrets

Regularly rotate JWT secrets in production.

## Example: Complete Auth Flow

```typescript
@Injectable()
export class AuthService {
  constructor(
    private readonly jwtService: JwtService,
    private readonly userService: UserService
  ) {}

  async login(username: string, password: string) {
    const user = await this.userService.validateCredentials(username, password);

    if (!user) {
      throw new UnauthorizedException("Invalid credentials");
    }

    const accessToken = await this.jwtService.sign({
      sub: user.id,
      username: user.username,
      role: user.role,
    });

    const refreshToken = await this.jwtService.sign(
      {
        sub: user.id,
        type: "refresh",
      },
      {
        expiresIn: "7d",
      }
    );

    return {
      access_token: accessToken,
      refresh_token: refreshToken,
      expires_in: 900, // 15 minutes in seconds
    };
  }

  async refresh(refreshToken: string) {
    const payload = await this.jwtService.verify(refreshToken);

    if (payload.type !== "refresh") {
      throw new UnauthorizedException("Invalid token type");
    }

    const newAccessToken = await this.jwtService.sign({
      sub: payload.sub,
    });

    return {
      access_token: newAccessToken,
    };
  }
}
```

## Next Steps

<Cards>
  <Card title="Authentication Guide" href="/docs/security/authentication" />
  <Card title="Guards" href="/docs/security/guards" />
  <Card title="Authorization" href="/docs/security/authorization" />
</Cards>
