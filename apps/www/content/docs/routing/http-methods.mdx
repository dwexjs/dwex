---
title: HTTP Methods
description: Handle different HTTP methods with decorators
---

## Overview

Dwex provides decorators for all standard HTTP methods. Each decorator defines how your route responds to specific HTTP verbs.

## Available Methods

### @Get()

Handle HTTP GET requests:

```typescript
import { Controller, Get } from "@dwexjs/core";

@Controller("users")
export class UserController {
	@Get()
	findAll() {
		return ["Alice", "Bob", "Charlie"];
	}

	@Get("active")
	findActive() {
		return ["Alice"];
	}
}
```

Routes:
- `GET /users` → `findAll()`
- `GET /users/active` → `findActive()`

### @Post()

Handle HTTP POST requests (create resources):

```typescript
import { Controller, Post, Body } from "@dwexjs/core";

@Controller("users")
export class UserController {
	@Post()
	create(@Body() data: CreateUserDto) {
		return { id: 1, ...data };
	}

	@Post("bulk")
	createMany(@Body() users: CreateUserDto[]) {
		return users.map((user, i) => ({ id: i + 1, ...user }));
	}
}
```

### @Put()

Handle HTTP PUT requests (full update):

```typescript
import { Controller, Put, Param, Body } from "@dwexjs/core";

@Controller("users")
export class UserController {
	@Put(":id")
	update(@Param("id") id: string, @Body() data: UpdateUserDto) {
		return { id, ...data, updated: true };
	}
}
```

### @Patch()

Handle HTTP PATCH requests (partial update):

```typescript
import { Controller, Patch, Param, Body } from "@dwexjs/core";

@Controller("users")
export class UserController {
	@Patch(":id")
	partialUpdate(@Param("id") id: string, @Body() data: Partial<UpdateUserDto>) {
		return { id, ...data, updated: true };
	}
}
```

### @Delete()

Handle HTTP DELETE requests:

```typescript
import { Controller, Delete, Param } from "@dwexjs/core";

@Controller("users")
export class UserController {
	@Delete(":id")
	remove(@Param("id") id: string) {
		return { id, deleted: true };
	}

	@Delete()
	removeAll() {
		return { deleted: true, count: 10 };
	}
}
```

### @Options()

Handle HTTP OPTIONS requests (CORS preflight):

```typescript
import { Controller, Options } from "@dwexjs/core";

@Controller("api")
export class ApiController {
	@Options()
	options() {
		return null;
	}
}
```

### @Head()

Handle HTTP HEAD requests:

```typescript
import { Controller, Head } from "@dwexjs/core";

@Controller("health")
export class HealthController {
	@Head()
	check() {
		return;
	}
}
```

### @All()

Handle all HTTP methods:

```typescript
import { Controller, All, Req } from "@dwexjs/core";

@Controller("webhook")
export class WebhookController {
	@All()
	handleWebhook(@Req() request: Request) {
		console.log(`Received ${request.method} request`);
		return { received: true };
	}
}
```

## Method Combinations

You can have multiple methods on the same path:

```typescript
@Controller("posts")
export class PostController {
	@Get(":id")
	findOne(@Param("id") id: string) {
		return { id, title: "Post Title" };
	}

	@Put(":id")
	update(@Param("id") id: string, @Body() data: UpdatePostDto) {
		return { id, ...data };
	}

	@Delete(":id")
	remove(@Param("id") id: string) {
		return { id, deleted: true };
	}
}
```

Routes:
- `GET /posts/:id`
- `PUT /posts/:id`
- `DELETE /posts/:id`

## RESTful Conventions

Follow REST conventions for consistency:

```typescript
@Controller("articles")
export class ArticleController {
	// GET /articles - List all articles
	@Get()
	findAll() {}

	// POST /articles - Create new article
	@Post()
	create(@Body() data: CreateArticleDto) {}

	// GET /articles/:id - Get single article
	@Get(":id")
	findOne(@Param("id") id: string) {}

	// PUT /articles/:id - Replace article
	@Put(":id")
	replace(@Param("id") id: string, @Body() data: ReplaceArticleDto) {}

	// PATCH /articles/:id - Update article fields
	@Patch(":id")
	update(@Param("id") id: string, @Body() data: UpdateArticleDto) {}

	// DELETE /articles/:id - Delete article
	@Delete(":id")
	remove(@Param("id") id: string) {}
}
```

## Nested Routes

Create nested resource routes:

```typescript
@Controller("users/:userId/posts")
export class UserPostController {
	// GET /users/:userId/posts
	@Get()
	findUserPosts(@Param("userId") userId: string) {
		return [];
	}

	// POST /users/:userId/posts
	@Post()
	createUserPost(@Param("userId") userId: string, @Body() data: CreatePostDto) {
		return { userId, ...data };
	}

	// GET /users/:userId/posts/:postId
	@Get(":postId")
	findUserPost(
		@Param("userId") userId: string,
		@Param("postId") postId: string,
	) {
		return { userId, postId };
	}
}
```

## Async Handlers

All methods support async/await:

```typescript
@Controller("users")
export class UserController {
	constructor(private readonly userService: UserService) {}

	@Get()
	async findAll() {
		return await this.userService.findAll();
	}

	@Post()
	async create(@Body() data: CreateUserDto) {
		return await this.userService.create(data);
	}

	@Delete(":id")
	async remove(@Param("id") id: string) {
		await this.userService.remove(id);
		return { success: true };
	}
}
```

## Status Codes

Default status codes by method:

- `@Get()` → 200 OK
- `@Post()` → 201 Created
- `@Put()` → 200 OK
- `@Patch()` → 200 OK
- `@Delete()` → 200 OK

Throw exceptions for error status codes:

```typescript
import {
	Controller,
	Get,
	Post,
	Param,
	Body,
	NotFoundException,
	BadRequestException,
} from "@dwexjs/core";

@Controller("users")
export class UserController {
	@Get(":id")
	findOne(@Param("id") id: string) {
		const user = this.findUserById(id);
		if (!user) {
			throw new NotFoundException("User not found");
		}
		return user;
	}

	@Post()
	create(@Body() data: CreateUserDto) {
		if (!data.email) {
			throw new BadRequestException("Email is required");
		}
		return this.createUser(data);
	}
}
```

## Best Practices

### 1. Use Appropriate Methods

Follow HTTP semantics:

- **GET**: Retrieve data (idempotent, no side effects)
- **POST**: Create resources or non-idempotent operations
- **PUT**: Replace entire resource (idempotent)
- **PATCH**: Update part of resource
- **DELETE**: Remove resource (idempotent)

### 2. Return Appropriate Data

```typescript
// GET - return data
@Get(':id')
findOne(@Param('id') id: string) {
	return { id, name: 'Alice' };
}

// POST - return created resource
@Post()
create(@Body() data: CreateUserDto) {
	return { id: 1, ...data };
}

// DELETE - return success or deleted resource
@Delete(':id')
remove(@Param('id') id: string) {
	return { success: true };
}
```

### 3. Consistent Naming

Use descriptive method names:

```typescript
@Get()
findAll() {} // Not: list(), get(), etc.

@Get(':id')
findOne() {} // Not: getById(), find(), etc.

@Post()
create() {} // Not: add(), insert(), etc.

@Delete(':id')
remove() {} // Not: delete(), destroy(), etc.
```

### 4. Validate Input

Always validate request data:

```typescript
@Post()
create(@Body() data: CreateUserDto) {
	if (!data.email || !data.password) {
		throw new BadRequestException('Email and password are required');
	}
	return this.userService.create(data);
}
```

## Next Steps

<Cards>
	<Card title="Route Parameters" href="/docs/routing/route-parameters" />
	<Card title="Request Data" href="/docs/routing/request-data" />
	<Card title="Response Handling" href="/docs/routing/response-handling" />
</Cards>
